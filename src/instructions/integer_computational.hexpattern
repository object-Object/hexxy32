#include "../macros/bytes.hexpattern"
#include "../macros/registers.hexpattern"

// TODO: we can probably just use the same handlers for I and R here, since registers are loaded while decoding

// register-immediate

#define Instruction 18: ADDI = num, num, num ->
// I-type
{
    Additive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 19: SLTI = num, num, num ->
// I-type
{
    Convert Unsigned to Signed
    Jester's Gambit
    Convert Unsigned to Signed
    Jester's Gambit

    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 20: SLTIU = num, num, num ->
// I-type
{
    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 21: XORI = num, num, num ->
// I-type
{
    Intersection Distillation
    Write Register
}

#define Instruction 22: ORI = num, num, num ->
// I-type
{
    Unifying Distillation
    Write Register
}

#define Instruction 23: ANDI = num, num, num ->
// I-type
{
    Exclusionary Distillation
    Write Register
}

#define Instruction 24: SLLI = num, num, num ->
// I-type
{
    Logical Shift Left
    Write Register
}

#define Instruction 25: SRLI = num, num, num ->
// I-type
{
    Logical Shift Right
    Write Register
}

#define Instruction 26: SRAI = num, num, num ->
// I-type
{
    Numerical Reflection: 5
    Truncate Integer
    Undertaker's Gambit
    Logical Shift Right

    Numerical Reflection: 32
    Rotation Gambit
    Subtractive Distillation
    Extend Sign

    Write Register
}

// register-register

#define Instruction 27: ADD = num, num, num ->
// R-type
{
    Additive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 28: SUB = num, num, num ->
// R-type
{
    Two's Complement Purification
    Additive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 29: SLL = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Logical Shift Left
    Write Register
}

#define Instruction 30: SLT = num, num, num ->
// R-type
{
    Convert Unsigned to Signed
    Jester's Gambit
    Convert Unsigned to Signed
    Jester's Gambit

    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 31: SLTU = num, num, num ->
// R-type
{
    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 32: XOR = num, num, num ->
// R-type
{
    Exclusionary Distillation
    Write Register
}

#define Instruction 33: SRL = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Logical Shift Right
    Write Register
}

#define Instruction 34: SRA = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Undertaker's Gambit
    Logical Shift Right

    Numerical Reflection: 32
    Rotation Gambit
    Subtractive Distillation
    Extend Sign

    Write Register
}

#define Instruction 35: OR = num, num, num ->
// R-type
{
    Jester's Gambit
    Unifying Distillation
    Write Register
}

#define Instruction 36: AND = num, num, num ->
// R-type
{
    Jester's Gambit
    Intersection Distillation
    Write Register
}
