#include "../macros/bytes.hexpattern"
#include "../macros/registers.hexpattern"

// TODO: we can probably just use the same handlers for I and R here, since registers are loaded while decoding

// register-immediate

#define Instruction 18: ADDI (e) = num, num, num ->
// I-type
{
    Additive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 19: SLTI (e) = num, num, num ->
// I-type
{
    Two's Complement Purification
    Jester's Gambit
    Two's Complement Purification
    Jester's Gambit

    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 20: SLTIU (e) = num, num, num ->
// I-type
{
    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 21: XORI (e) = num, num, num ->
// I-type
{
    Intersection Distillation
    Write Register
}

#define Instruction 22: ORI (e) = num, num, num ->
// I-type
{
    Unifying Distillation
    Write Register
}

#define Instruction 23: ANDI (e) = num, num, num ->
// I-type
{
    Exclusionary Distillation
    Write Register
}

#define Instruction 24: SLLI (e) = num, num, num ->
// I-type
{
    Logical Shift Left
    Write Register
}

#define Instruction 25: SRLI (e) = num, num, num ->
// I-type
{
    Logical Shift Right
    Write Register
}

#define Instruction 26: SRAI (e) = num, num, num ->
// I-type
{
    Numerical Reflection: 5
    Truncate Integer
    Undertaker's Gambit
    Logical Shift Right

    Numerical Reflection: 32
    Rotation Gambit
    Subtractive Distillation
    Extend Sign

    Write Register
}

// register-register

#define Instruction 27: ADD (e) = num, num, num ->
// R-type
{
    Additive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 28: SUB (e) = num, num, num ->
// R-type
{
    Subtractive Distillation
    Numerical Reflection: 32
    Truncate Integer
    Write Register
}

#define Instruction 29: SLL (e) = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Logical Shift Left
    Write Register
}

#define Instruction 30: SLT (e) = num, num, num ->
// R-type
{
    Two's Complement Purification
    Jester's Gambit
    Two's Complement Purification
    Jester's Gambit

    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 31: SLTU (e) = num, num, num ->
// R-type
{
    Minimus Distillation
    Numerical Reflection: 1
    Numerical Reflection: 0
    Augur's Exaltation

    Write Register
}

#define Instruction 32: XOR (e) = num, num, num ->
// R-type
{
    Exclusionary Distillation
    Write Register
}

#define Instruction 33: SRL (e) = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Logical Shift Right
    Write Register
}

#define Instruction 34: SRA (e) = num, num, num ->
// R-type
{
    Numerical Reflection: 5
    Truncate Integer
    Undertaker's Gambit
    Logical Shift Right

    Numerical Reflection: 32
    Rotation Gambit
    Subtractive Distillation
    Extend Sign

    Write Register
}

#define Instruction 35: OR (e) = num, num, num ->
// R-type
{
    Jester's Gambit
    Unifying Distillation
    Write Register
}

#define Instruction 36: AND (e) = num, num, num ->
// R-type
{
    Jester's Gambit
    Intersection Distillation
    Write Register
}
